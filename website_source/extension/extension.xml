<?xml version="1.0" encoding="ISO-8859-1"?><XPAGES>
  <INFORMATIONS><LABEL>extension</LABEL>
    <TITRE>Extending Daxe</TITRE>
    <DATECRE>20/3/2017</DATECRE>
    <LANGUE>en</LANGUE>
  </INFORMATIONS>
  <PAGE label="introduction" titre="Introduction">
    <PARAGRAPHE>
      XML editors which do not have knowledge of specific XML languages cannot provide a very good user interface. For instance, it would be hard to edit HTML documents if the <CODE>p</CODE> (paragraph) and <CODE>a</CODE> (anchor or link) elements from HTML were displayed in the same way. One is a block element, separating parts of the text, while the other is an inline element, which can be mixed with text. While some (usually data-oriented) XML languages can easily be edited with a tree, a tree user interface does not work so well with other XML languages.
    </PARAGRAPHE>
    <PARAGRAPHE>
      On the other hand, creating a new editor from scratch for each XML language is not the most efficient solution, as at least half of the code will be the same from one editor to another. For instance, all editors have to ensure document validity, and they have to provide ways to edit content with a cursor aware of the XML structure. Common parts of XML editors should be reused.
    </PARAGRAPHE>
    <PARAGRAPHE>
      Daxe is an answer to these questions: it provides all the building blocks for a new XML editor for a specific language, many predefined displays for elements which can be associated to the language XML elements, and ways to extend it further and include it into a larger application.
    </PARAGRAPHE>
    <PARAGRAPHE>
      <LIENPAGE contribution="doc-config-en">Daxe configuration files</LIENPAGE> provide an easy way to customize the editor for a given XML language using built-in solutions. The following pages describe how to go beyond what can be done with configuration files, especially to create new display types.
    </PARAGRAPHE>
  </PAGE>
  <PAGE label="creating-a-new-extension" titre="Creating a new extension">
    <PARAGRAPHE>
      An extension of Daxe has to be implemented in <LIENWEB url="https://www.dartlang.org/">Dart</LIENWEB>, so the Dart SDK needs to be installed. Daxe's API documentation can be generated from the the source with the <LIENWEB url="https://github.com/dart-lang/dartdoc">dartdoc</LIENWEB> command launched in the root of the source tree (the <CODE>daxe</CODE> directory).
    </PARAGRAPHE>
    <PARAGRAPHE>
      An extension is a Dart web application. Here is a basic example, adding a new display type named <CODE>mydn</CODE> with the class <CODE>MyDN</CODE>. This code would be in a file named <CODE>my_daxe.dart</CODE>:
    </PARAGRAPHE>
    <CODE>
      library my_daxe;
      
      import 'package:daxe/daxe.dart';
      part 'my_dn.dart';
      
      void main() {
        NodeFactory.addCoreDisplayTypes();
        
        setDisplayType('mydn',
              (x.Element ref) =&gt; new MyDN.fromRef(ref),
              (x.Node node, DaxeNode parent) =&gt; new MyDN.fromNode(node, parent)
          );
      
        Strings.load().then((bool b) {
          initDaxe();
        }).catchError((e) {
          h.document.body.appendText('Error when loading the strings.');
        });
      }
    </CODE>
  </PAGE>
  <PAGE label="creating-new-display-types" titre="Creating new display types">
    <PARAGRAPHE>
      A display type is defined by a class deriving from the <CODE>DaxeNode</CODE> class in the <CODE>daxe</CODE> package.
    </PARAGRAPHE>
    <PARAGRAPHE>
      The implementation of the display type class needs 2 constructors, <CODE>.fromRef()</CODE> to create a new instance from the language definition of the element, and <CODE>.fromNode()</CODE>, to create a new instance from a DOM node. It also needs at least one method, <CODE>html()</CODE>, which returns the DOM node for the node to display, with the node <CODE>id</CODE>. As an example, let's look at the implementation for the <CODE>string</CODE> display, which is simply an inline display with a start tag and an end tag:
    </PARAGRAPHE>
    <CODE>
      part of nodes;
      
      class DNString extends DaxeNode {
        Tag _b1, _b2;
        
        DNString.fromRef(x.Element elementRef) : super.fromRef(elementRef) {
          _b1 = new Tag(this, Tag.START);
          _b2 = new Tag(this, Tag.END);
        }
        
        DNString.fromNode(x.Node node, DaxeNode parent) : super.fromNode(node, parent) {
          _b1 = new Tag(this, Tag.START);
          _b2 = new Tag(this, Tag.END);
        }
        
        @override
        h.Element html() {
          var span = new h.SpanElement();
          span.id = "$id";
          span.classes.add('dn');
          if (!valid)
            span.classes.add('invalid');
          span.append(_b1.html());
          var contents = new h.SpanElement();
          DaxeNode dn = firstChild;
          while (dn != null) {
            contents.append(dn.html());
            dn = dn.nextSibling;
          }
          setStyle(contents);
          span.append(contents);
          span.append(_b2.html());
          return(span);
        }
        
        @override
        h.Element getHTMLContentsNode() {
          return(getHTMLNode().nodes[1]);
        }
      }
    </CODE>
    <PARAGRAPHE>
      The constructors derive from the <CODE>fromRef()</CODE> and <CODE>fromNode()</CODE> constructors in <CODE>DaxeNode</CODE>, doing all the basic initialization for free. The start and end tags are created in the constructors, using the <CODE>Tag</CODE> class. The <CODE>html()</CODE> method creates a <CODE>span</CODE> for the DOM node, sets the id based on <CODE>DaxeNode.id</CODE>, adds an <CODE>invalid</CODE> CSS class if necessary, and appends the tags' HTML nodes and the contents in another span. Style is applied to the contents with <CODE>DaxeNode.setStyle()</CODE>, and the span is returned.
    </PARAGRAPHE>
    <PARAGRAPHE>
      Another method is overridden, <CODE>getHTMLContentsNode()</CODE>, to return the DOM node containing the children, which can be different depending on the implementation of <CODE>html()</CODE>. In this case, we can simply return the second child of the node's DOM node, which we can get with <CODE>DaxeNode.getHTMLNode()</CODE>.
    </PARAGRAPHE>
    <PARAGRAPHE>
      While all display type classes have to derive from <CODE>DaxeNode</CODE>, all the methods can be overridden, so these classes have complete control over appearance and resulting DOM, for the node itself and all the descendants.
    </PARAGRAPHE>
  </PAGE>
  <PAGE label="more-customization" titre="More customization">
    <PARAGRAPHE>
      Configuration files can be used to customize the menus used to insert nodes, but it is also possible to define menus with custom functions, and only a Daxe extension can implement these. It is also easy to customize the toolbar, the left panel, and the function used to save documents.
    </PARAGRAPHE>
    <PARAGRAPHE>
      Function menus in configuration files are defined with a <CODE>FUNCTION_MENU</CODE> element, and these have a <CODE>function_name</CODE> attribute with the function name. This function can be added to Daxe in an extension with the <CODE>addCustomFunction()</CODE> function in the <CODE>daxe</CODE> package.
    </PARAGRAPHE>
    <PARAGRAPHE>
      More customization can be done by passing named parameters to the <CODE>initDaxe()</CODE> function:
    </PARAGRAPHE>
    <LISTE>
      <ITEM><CODE>left</CODE>: should be a <CODE>LeftPanel</CODE> or a class deriving from it, representing the left panel</ITEM>
      <ITEM><CODE>saveFunction</CODE>: a function called when the document should be saved (by default, <CODE>doc.save()</CODE>)</ITEM>
      <ITEM><CODE>customizeToolbar</CODE>: a function called at the right time to customize the toolbar (after <CODE>page.toolbar</CODE> is created but before the HTML is generated)</ITEM>
    </LISTE>
    <PARAGRAPHE>
      On top of that, more code can be executed after initialization, by using the fact that <CODE>initDaxe()</CODE> returns a Future. Here is an example combining different customizations:
    </PARAGRAPHE>
    <PARAGRAPHE>
      (Daxe's DOM package is included with <CODE>import 'package:daxe/src/xmldom/xmldom.dart' as x;</CODE> in this example)
    </PARAGRAPHE>
    <CODE>
        // use a custom insert panel, MyOwnInsertPanel, implemented elsewhere
        InsertPanel insertP = new MyOwnInsertPanel();
        LeftPanel left = new LeftPanel(insert:insertP);
        ActionFunction saveFunction= () {
          // display an alert after a save
          doc.save().then((_) {
            h.window.alert(Strings.get('save.success'));
          }, onError: (DaxeException ex) {
            h.window.alert(Strings.get('save.error') + ': ' + ex.message);
          });
        };
        ActionFunction customizeToolbar = () {
          // add a button to insert a mydn node
          Toolbar toolbar = page.toolbar;
          List&lt;x.Element&gt; refs = doc.cfg.elementsWithType('mydn');
          if (refs != null &amp;&amp; refs.length &gt; 0) {
            ToolbarBox myBox = new ToolbarBox();
            toolbar.addInsertButton(doc.cfg, myBox, refs, 'my_dn.png');
            toolbar.add(myBox);
          }
        };
        Strings.load().then((bool b) {
          initDaxe(left:left, saveFunction:saveFunction,
              customizeToolbar:customizeToolbar).then((v) {
            // more customizations can be added here
          }).catchError((e) {
            String msg = 'Initialization error: ' + (e is String ? e : e.toString());
            print(msg);
            h.document.body.appendText(msg);
          });
        }).catchError((e) {
          String msg = 'Initialization error: ' + (e is String ? e : e.toString());
          print(msg);
          h.document.body.appendText(msg);
        });
    </CODE>
    <PARAGRAPHE>
      A large example of an extension is LON-CAPA Daxe, which lets LON-CAPA users edit documents using the LON-CAPA language, featuring a mix of HTML and custom elements for online problems. The source code is currently (as of 2017) available <LIENWEB url="http://source.lon-capa.org/cgi-bin/cvsweb.cgi/modules/damieng/graphical_editor/loncapa_daxe/">here</LIENWEB>.
    </PARAGRAPHE>
  </PAGE>
</XPAGES>